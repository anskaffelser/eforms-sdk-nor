#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'pathname'
require 'optparse'

# --- 1. ARGUMENT PARSING ---
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: assemble_national_e_json.rb [options]"

  opts.on("--input DIR", "Directory containing fragments") { |v| options[:input] = Pathname.new(v) }
  opts.on("--output FILE", "Path to the final output file") { |v| options[:output] = Pathname.new(v) }
  opts.on("--template FILE", "Path to the license header template") { |v| options[:template] = Pathname.new(v) }
end.parse!

# Fallback til defaults hvis de ikke er definert (valgfritt)
FRAGMENTS_DIR = options[:input]    || raise("Missing --input")
OUT_PATH      = options[:output]   || raise("Missing --output")
HEADER_PATH   = options[:template] || raise("Missing --template")

# --- 2. DATA STRUCTURE ---
out = {
  'noticeTypes' => [],
  'aliases'     => {},
  'fields'      => {},
  'rules'       => {},
  'removed'     => []
}

# --- 3. MERGING STRATEGIES ---
# Her definerer vi "kontrakten" for de ulike filtypene.
# Dette gj√∏r det ekstremt lett √• legge til nye typer fragmenter senere.
MERGE_LOGIC = {
  '.fields.fragment.yaml' => ->(data) { 
    out['fields'].merge!(data) 
  },
  '.rules.fragment.yaml' => ->(data) { 
    data.each { |target, entries| (out['rules'][target] ||= []).concat(Array(entries)) } 
  },
  '.noticetypes.fragment.yaml' => ->(data) { 
    out['noticeTypes'] = (out['noticeTypes'] + Array(data)).uniq.sort
    out['aliases']     = out['noticeTypes'].to_h { |nt| [nt, nt] }
  }
}

# --- 4. HEADER LOADING ---
begin
  header = File.read(HEADER_PATH).gsub('<OUTPUT_FILENAME>', OUT_PATH.basename.to_s)
rescue Errno::ENOENT
  header = "# National Ruleset Monolith (Autogenerated)\n"
end

# --- 5. MAIN ASSEMBLY ---
puts "Merging fragments from #{FRAGMENTS_DIR}..."

# Finn alle fragment-filer og sorter dem for deterministisk output
fragment_files = Dir[FRAGMENTS_DIR.join('*.fragment.yaml')].sort

fragment_files.each do |path|
  filename = File.basename(path)
  data     = YAML.load_file(path, aliases: true)
  
  # Finn ut hvilken logikk som skal brukes basert p√• filendelsen
  # Vi sjekker hvilken n√∏kkel i MERGE_LOGIC som finnes i filnavnet
  suffix, action = MERGE_LOGIC.find { |ext, _| filename.include?(ext) }

  if action
    action.call(data)
    type_label = suffix.split('.')[1].upcase
    puts "  [#{type_label.ljust(6)}] merged: #{filename}"
  else
    puts "  ‚ö†Ô∏è  [SKIP]   Unknown fragment type (check naming convention): #{filename}"
  end
end

# --- 6. CLEANING & SORTING ---
# Sorter fields alfabetisk etter n√∏kkel
out['fields'] = out['fields'].sort.to_h

# Sorter rules alfabetisk etter n√∏kkel (felt-ID)
out['rules'] = out['rules'].sort.to_h

# Sorter ogs√• reglene innad i hvert felt hvis du vil ha det helt perfekt
out['rules'].each do |field_id, rule_list|
  # Her sorterer vi etter ID-en p√• selve regelen (EFORMS-NOR-...)
  out['rules'][field_id] = rule_list.sort_by { |r| r['id'] }
end

# --- 7. WRITE OUTPUT ---
yaml_content = out.to_yaml(line_width: -1)

OUT_PATH.dirname.mkpath unless OUT_PATH.dirname.exist?
File.write(OUT_PATH, header + yaml_content)

puts "------------------------------------------------------------"
puts "‚úÖ SUCCESS: #{OUT_PATH.basename} assembled."
puts "üìä Stats: #{out['fields'].size} fields, #{out['rules'].size} rule blocks."
puts "------------------------------------------------------------"
