#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'pathname'

# --- 1. CONFIG & PATHS ---
BASE          = Pathname.new(__dir__).join('../../..').expand_path
POLICY_DIR    = BASE.join('src/policy/national')
FRAGMENTS_DIR = BASE.join('src/generated/national')
OUT_PATH      = BASE.join('src/fields/national.rules.yaml')
HEADER_PATH   = POLICY_DIR.join("templates/LICENSE_HEADER.monolith.txt")

# --- 2. DATA STRUCTURE ---
out = {
  'noticeTypes' => [],
  'aliases'     => {},
  'fields'      => {},
  'rules'       => {},
  'removed'     => []
}

# --- 3. MERGING STRATEGIES ---
# Her definerer vi "kontrakten" for de ulike filtypene.
# Dette gj√∏r det ekstremt lett √• legge til nye typer fragmenter senere.
MERGE_LOGIC = {
  '.fields.fragment.yaml' => ->(data) { 
    out['fields'].merge!(data) 
  },
  '.rules.fragment.yaml' => ->(data) { 
    data.each { |target, entries| (out['rules'][target] ||= []).concat(Array(entries)) } 
  },
  '.noticetypes.fragment.yaml' => ->(data) { 
    out['noticeTypes'] = (out['noticeTypes'] + Array(data)).uniq.sort
    out['aliases']     = out['noticeTypes'].to_h { |nt| [nt, nt] }
  }
}

# --- 4. HEADER LOADING ---
begin
  header = File.read(HEADER_PATH).gsub('<OUTPUT_FILENAME>', OUT_PATH.basename.to_s)
rescue Errno::ENOENT
  header = "# National Ruleset Monolith (Autogenerated)\n"
end

# --- 5. MAIN ASSEMBLY ---
puts "Merging fragments from #{FRAGMENTS_DIR}..."

# Finn alle fragment-filer og sorter dem for deterministisk output
fragment_files = Dir[FRAGMENTS_DIR.join('*.fragment.yaml')].sort

fragment_files.each do |path|
  filename = File.basename(path)
  data     = YAML.load_file(path, aliases: true)
  
  # Finn ut hvilken logikk som skal brukes basert p√• filendelsen
  # Vi sjekker hvilken n√∏kkel i MERGE_LOGIC som finnes i filnavnet
  suffix, action = MERGE_LOGIC.find { |ext, _| filename.include?(ext) }

  if action
    action.call(data)
    type_label = suffix.split('.')[1].upcase
    puts "  [#{type_label.ljust(6)}] merged: #{filename}"
  else
    puts "  ‚ö†Ô∏è  [SKIP]   Unknown fragment type (check naming convention): #{filename}"
  end
end

# --- 6. WRITE OUTPUT ---
yaml_content = out.to_yaml(line_width: -1)

OUT_PATH.dirname.mkpath unless OUT_PATH.dirname.exist?
File.write(OUT_PATH, header + yaml_content)

puts "------------------------------------------------------------"
puts "‚úÖ SUCCESS: #{OUT_PATH.basename} assembled."
puts "üìä Stats: #{out['fields'].size} fields, #{out['rules'].size} rule blocks."
puts "------------------------------------------------------------"
